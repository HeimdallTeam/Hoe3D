// -*-C-*- vi: set ft=c:
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * Hoe edited flex.skl
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION FLEX_MAJOR_VERSION
#define YY_FLEX_MINOR_VERSION FLEX_MINOR_VERSION
#define YY_FLEX_SUBMINOR_VERSION FLEX_SUBMINOR_VERSION
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef _WIN32
#include <windows.h>
#endif

#ifdef _LINUX
#define _NOXLIB
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <wchar.h>
#include <stdarg.h>
#include <HoeCore/hoe_types.h>
#include <HoeCore/hoe_flex.h>

using namespace HoeCore::flex;


#define yytext yytext_ptr

namespace HoeCore {
namespace flex {

#if 0
//%% YY_CHAR and YY_SC_TO_UI() go here
//%% YY_CHAR and YY_SC_TO_UI() go here
//end %% YY_CHAR and YY_SC_TO_UI() go here

#endif

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER m_buffer
#define YY_CURRENT_BUFFER_LVALUE m_buffer
#define YY_BUF_SIZE 1024

int yyleng;

#define yy_new_buffer yy_create_buffer

#define yy_set_bol(at_bol) \
	{ \
	if ( ! m_buffer ) \
		m_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	m_buffer->SetBol(at_bol); \
	}

#define YY_AT_BOL() (m_buffer->IsBol())

#define M4_YY_INCR_LINENO() 

#if 0
//%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
//end %% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
#else
//extern YY_CHAR *yytext;
#endif

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
/*%% code to fiddle yytext and yyleng for yymore() goes here */ \
%% code to fiddle yytext and yyleng for yymore() goes here
/*end %% code to fiddle yytext and yyleng for yymore() goes here*/ \
	yy_hold_char = *yy_cp; \
	*yy_cp = (YY_CHAR) '\0'; \
/*%% code to copy yytext_ptr to yytext[] goes here, if %array*/ \
%% code to copy yytext_ptr to yytext[] goes here, if %array
/* end %% code to copy yytext_ptr to yytext[] goes here, if %array*/ \
	yy_c_buf_p = yy_cp;

} //namespace flex
} //namespace HoeCore

//%% data tables for the DFA and the user's section 1 definitions go here
%% data tables for the DFA and the user's section 1 definitions go here
//end of %% data tables for the DFA and the user's section 1 definitions go here

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

 int yywrap ( void ) { return 1; }

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state ( int new_state );
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state ( void );
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state ( void );
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

/* Echo output. */
#define ECHO \
	do { \
	 int s = this->Echo( (YY_CHAR*)yytext_ptr, yyleng ); \
	 if (s) return s; \
	} while (0);

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#if 0
%% fread()/read() definition of YY_INPUT goes here unless we're doing C++

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#define YY_BREAK break;

#if 0
%% YY_RULE_SETUP definition goes here

#else
#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		m_buffer->SetBol(yytext_ptr[yyleng - 1] == '\n'); \
	YY_USER_ACTION
#endif


#ifdef YY_CLASS_DECL
int YY_CLASS_NAME::YY_CLASS_DECL
#else
int YY_CLASS_NAME::Lex()
#endif
{
	register HoeCore::flex::yy_state_type yy_current_state;
	register HoeCore::flex::YY_CHAR *yy_cp, *yy_bp;
	register int yy_act;
	const int yy_start = 1;

//%% user's declarations go here
%% user's declarations go here
//end %% user's declarations go here

/*#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif*/

	if (!m_buffer)
		return YY_NULL;

	while ( 1 )		/* loops until end-of-file is reached */
		{
//%% yymore()-related code goes here
%% yymore()-related code goes here
//end %% yymore()-related code goes here
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

//%% code to set up and find next match goes here
%% code to set up and find next match goes here
//end %% code to set up and find next match goes here

yy_find_action:
//%% code to find the action number goes here
%% code to find the action number goes here
//end%% code to find the action number goes here

		YY_DO_BEFORE_ACTION;

#if 0 
//%% code for yylineno update goes here
%% code for yylineno update goes here
//end %% code for yylineno update goes here

#else
		if ( yy_act != YY_END_OF_BUFFER )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					m_buffer->IncLineNo();
			}
#endif //end%% code for yylineno update goes here

do_action:	/* This label is used only to access EOF actions. */

//%% debug code goes here
%% debug code goes here
//end %% debug code goes here

		switch ( yy_act )
	{ /* beginning of action switch */
//%% actions go here
%% actions go here
//end %% actions go here

	case YY_END_OF_BUFFER:
		{
			/* end of buffer -> newread or end */
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( m_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between m_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = m_buffer->yy_n_chars;
			//m_buffer->yy_input_file = stdin;
			m_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &m_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */ 
				/* prislo nul => teoreticky staci jeden*/
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
//%% code to do back-up for compressed tables and set up yy_cp goes here
%% code to do back-up for compressed tables and set up yy_cp goes here
//end %% code to do back-up for compressed tables and set up yy_cp goes here
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&m_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(T("fatal flex scanner internal error--no action found"));
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

/* yy_get_previous_state - get the state just before the EOB char was reached */

yy_state_type YY_CLASS_NAME::yy_get_previous_state()
{
	register yy_state_type yy_current_state;
	register YY_CHAR *yy_cp;
	const int yy_start = 1;

//%% code to get the start state into yy_current_state goes here
%% code to get the start state into yy_current_state goes here
//end %% code to get the start state into yy_current_state goes here

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
//%% code to find the next state goes here
%% code to find the next state goes here
//end %% code to find the next state goes here
		}

	return yy_current_state;
}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YY_CLASS_NAME::yy_try_NUL_trans( yy_state_type yy_current_state )
{
	register int yy_is_jam;
//%% code to find the next state, and perhaps do backing up, goes here
%% code to find the next state, and perhaps do backing up, goes here
//end %% code to find the next state, and perhaps do backing up, goes here

	return yy_is_jam ? 0 : yy_current_state;
}

#if 0
//%% update yylineno here
%% update yylineno here
//end %% update yylineno here
//
//%% update BOL and yylineno
%% update BOL and yylineno
//end %% update BOL and yylineno
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = (YY_CHAR) '\0'; \
		yyleng = n; \
		} \
	while ( 0 )






