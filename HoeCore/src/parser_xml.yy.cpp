#line 2 "src/parser_xml.yy.cpp"

#line 4 "src/parser_xml.yy.cpp"

#define  YY_INT_ALIGNED short int

// -*-C-*- vi: set ft=c:
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * Hoe edited flex.skl
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION FLEX_MAJOR_VERSION
#define YY_FLEX_MINOR_VERSION FLEX_MINOR_VERSION
#define YY_FLEX_SUBMINOR_VERSION FLEX_SUBMINOR_VERSION
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef _WIN32
#include <windows.h>
#endif

#ifdef _LINUX
#define _NOXLIB
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <wchar.h>
#include <stdarg.h>
#include <HoeCore/hoe_types.h>
#include <HoeCore/hoe_flex.h>

#define yytext yytext_ptr

#define YY_CHAR tchar

namespace HoeCore {
namespace flex {

#if 0
//%% YY_CHAR and YY_SC_TO_UI() go here
//%% YY_CHAR and YY_SC_TO_UI() go here
//end %% YY_CHAR and YY_SC_TO_UI() go here

#endif

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER m_buffer
#define YY_CURRENT_BUFFER_LVALUE m_buffer

#define yy_new_buffer yy_create_buffer

#define yy_set_bol(at_bol) \
	{ \
	if ( ! m_buffer ) \
		m_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	m_buffer->SetBol(at_bol); \
	}

#define YY_AT_BOL() (m_buffer->IsBol())

#define M4_YY_INCR_LINENO() 

#if 0
//%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char *yytext;
#define yytext_ptr yytext
//end %% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
#else
//extern YY_CHAR *yytext;
#endif

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
/*%% code to fiddle yytext and yyleng for yymore() goes here */ \
	yyleng = (size_t) (yy_cp - yy_bp); \
/*end %% code to fiddle yytext and yyleng for yymore() goes here*/ \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
/*%% code to copy yytext_ptr to yytext[] goes here, if %array*/ \
/* end %% code to copy yytext_ptr to yytext[] goes here, if %array*/ \
	yy_c_buf_p = yy_cp;

} //namespace flex
} //namespace HoeCore

using namespace HoeCore::flex;

//%% data tables for the DFA and the user's section 1 definitions go here
#define YY_NUM_RULES 11
#define YY_END_OF_BUFFER 12
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_accept[56] =
    {   0,
        0,    0,   10,   10,   12,   11,    1,    2,   11,   11,
        7,   11,   10,    1,    2,   10,    7,   10,    1,    8,
        0,    0,    0,    5,    0,    0,    0,   10,    1,    8,
       10,   10,   10,    0,    0,    0,    0,    0,   10,   10,
        0,    9,    0,    0,    6,   10,    6,    0,    0,    0,
        0,    0,    3,    4,    0
    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    5,    6,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    7,    1,    8,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    9,
       10,   11,   12,    1,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        1,    1,    1,    1,    1,    1,   14,   14,   14,   14,

       14,   14,   14,   14,   14,   14,   14,   15,   16,   14,
       14,   14,   14,   14,   14,   14,   14,   14,   14,   17,
       14,   14,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[18] =
    {   0,
        1,    2,    1,    3,    4,    1,    1,    4,    3,    2,
        5,    4,    6,    7,    7,    7,    7
    } ;

static yyconst flex_int16_t yy_base[65] =
    {   0,
        0,    0,   17,    0,   97,  139,   33,  139,   82,   33,
      139,   34,    0,   38,    0,   81,    0,   44,   45,  139,
       84,    0,   73,    0,   41,   46,   53,    0,   60,    0,
       55,   64,    0,   79,   72,   66,   65,   74,   66,   69,
       70,  139,   61,   68,  139,   75,    0,   62,   49,   42,
       39,   28,  139,  139,  139,   81,   87,   94,  101,  103,
      110,  117,  124,  131
    } ;

static yyconst flex_int16_t yy_def[65] =
    {   0,
       55,    1,   55,    3,   55,   55,   55,   55,   55,   56,
       55,   57,   58,   58,   58,   58,   58,   58,   55,   55,
       55,   59,   55,   60,   55,   55,   57,   58,   58,   58,
       58,   58,   18,   55,   59,   55,   55,   61,   58,   62,
       63,   55,   55,   61,   55,   62,   58,   63,   55,   64,
       55,   64,   55,   55,    0,   55,   55,   55,   55,   55,
       55,   55,   55,   55
    } ;

static yyconst flex_int16_t yy_nxt[157] =
    {   0,
        6,    7,    8,    7,    6,    6,    6,    9,   10,    6,
       11,    6,    6,   12,   12,   12,   12,   13,   14,   15,
        7,   13,   13,   13,   16,   10,   13,   17,   13,   13,
       18,   18,   18,   18,   19,   25,   19,   21,   53,   29,
       22,   19,   25,   26,   23,   31,   19,   37,   19,   54,
       26,   38,   53,   32,   25,   51,   31,   33,   33,   33,
       33,   29,   26,   19,   32,   39,   37,   39,   49,   40,
       38,   40,   44,   45,   47,   50,   49,   44,   44,   45,
       47,   43,   42,   44,   24,   41,   24,   24,   27,   36,
       34,   30,   20,   27,   28,   28,   55,   28,   28,   28,

       28,   35,   35,   35,   35,   55,   35,   35,   24,   24,
       44,   44,   44,   44,   44,   44,   44,   46,   46,   46,
       46,   46,   46,   46,   48,   48,   48,   48,   48,   48,
       48,   52,   52,   52,   52,   52,   52,   52,    5,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55
    } ;

static yyconst flex_int16_t yy_chk[157] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    7,   12,    7,   10,   52,   14,
       10,   14,   25,   12,   10,   18,   19,   26,   19,   51,
       25,   26,   50,   18,   27,   49,   31,   18,   18,   18,
       18,   29,   27,   29,   31,   32,   37,   39,   48,   32,
       37,   39,   40,   44,   40,   43,   41,   40,   46,   38,
       46,   36,   35,   46,   56,   34,   56,   56,   57,   23,
       21,   16,    9,   57,   58,   58,    5,   58,   58,   58,

       58,   59,   59,   59,   59,    0,   59,   59,   60,   60,
       61,   61,   61,   61,   61,   61,   61,   62,   62,   62,
       62,   62,   62,   62,   63,   63,   63,   63,   63,   63,
       63,   64,   64,   64,   64,   64,   64,   64,   55,   55,
       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   55,   55,   55
    } ;

/* Table of booleans, true if rule could match eol. */
static yyconst flex_int32_t yy_rule_can_match_eol[12] =
    {   0,
0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0,     };

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "src/parser_xml.l"
#line 3 "src/parser_xml.l"
#include "StdAfx.h"
#include "../include/HoeCore/struct_file.h"
#define YY_CLASS_NAME HoeCore::XMLParser
#define YY_CLASS_DECL Lex(StructParserSAX& parser)


#line 278 "src/parser_xml.yy.cpp"
//end of %% data tables for the DFA and the user's section 1 definitions go here

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state ( int new_state );
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state ( void );
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state ( void );
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

/* Echo output. */
#define ECHO \
	do { \
	 int s = this->Echo( yytext_ptr, yyleng ); \
	 if (s) return s; \
	} while (0);

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#if 0
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#define YY_BREAK break;

#if 0
#define YY_RULE_SETUP \
	YY_USER_ACTION

#else
#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		m_buffer->SetBol(yytext_ptr[yyleng - 1] == '\n'); \
	YY_USER_ACTION
#endif

#ifdef YY_CLASS_DECL
int YY_CLASS_NAME::YY_CLASS_DECL
#else
int YY_CLASS_NAME::Lex()
#endif
{
	register HoeCore::flex::yy_state_type yy_current_state;
	register tchar *yy_cp, *yy_bp;
	register int yy_act;
	yy_start = 1; // initial state

//%% user's declarations go here
#line 22 "src/parser_xml.l"

#line 391 "src/parser_xml.yy.cpp"
//end %% user's declarations go here

/*#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif*/

	if (!m_buffer)
		return YY_NULL;

	while ( 1 )		/* loops until end-of-file is reached */
		{
//%% yymore()-related code goes here
//end %% yymore()-related code goes here
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

//%% code to set up and find next match goes here
		yy_current_state = YY_G(yy_start);
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				YY_G(yy_last_accepting_state) = yy_current_state;
				YY_G(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 56 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 139 );
//end %% code to set up and find next match goes here

yy_find_action:
//%% code to find the action number goes here
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = YY_G(yy_last_accepting_cpos);
			yy_current_state = YY_G(yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}
//end%% code to find the action number goes here

		YY_DO_BEFORE_ACTION;

#if 0 
//%% code for yylineno update goes here

		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					M4_YY_INCR_LINENO();
			}

//end %% code for yylineno update goes here

#else
		if ( yy_act != YY_END_OF_BUFFER )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					m_buffer->IncLineNo();
			}
#endif //end%% code for yylineno update goes here

do_action:	/* This label is used only to access EOF actions. */

//%% debug code goes here
//end %% debug code goes here

		switch ( yy_act )
	{ /* beginning of action switch */
//%% actions go here
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = YY_G(yy_hold_char);
			yy_cp = YY_G(yy_last_accepting_cpos);
			yy_current_state = YY_G(yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 23 "src/parser_xml.l"
/* skip */
	YY_BREAK
case 2:
/* rule 2 can match eol */
YY_RULE_SETUP
#line 24 "src/parser_xml.l"
/* skip */
	YY_BREAK
case 3:
/* rule 3 can match eol */
YY_RULE_SETUP
#line 25 "src/parser_xml.l"
/* skip */
	YY_BREAK
case 4:
/* rule 4 can match eol */
YY_RULE_SETUP
#line 26 "src/parser_xml.l"
/* skip */
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 27 "src/parser_xml.l"
parser.Begin(yytext_ptr+1); BEGIN(INITIAL);
	YY_BREAK
case 6:
/* rule 6 can match eol */
YY_RULE_SETUP
#line 28 "src/parser_xml.l"
this->SetProp(parser, yytext_ptr);
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 29 "src/parser_xml.l"
BEGIN(XMLTEXT);
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 30 "src/parser_xml.l"
BEGIN(XMLTEXT);parser.End();
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 31 "src/parser_xml.l"
parser.End(); BEGIN(INITIAL); // end
	YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 33 "src/parser_xml.l"
parser.SetProp(m_textprop, yytext_ptr);
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 35 "src/parser_xml.l"
ECHO;
	YY_BREAK
#line 550 "src/parser_xml.yy.cpp"
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(XMLTEXT):
	yyterminate();
//end %% actions go here

	case YY_END_OF_BUFFER:
		{
			/* end of buffer -> newread or end */
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( m_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between m_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = m_buffer->yy_n_chars;
			//m_buffer->yy_input_file = stdin;
			m_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &m_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */ 
				/* prislo nul => teoreticky staci jeden*/
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
//%% code to do back-up for compressed tables and set up yy_cp goes here
				yy_cp = YY_G(yy_c_buf_p);
//end %% code to do back-up for compressed tables and set up yy_cp goes here
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&m_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(T("fatal flex scanner internal error--no action found"));
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

/* yy_get_previous_state - get the state just before the EOB char was reached */

yy_state_type YY_CLASS_NAME::yy_get_previous_state()
{
	register yy_state_type yy_current_state;
	register tchar *yy_cp;

//%% code to get the start state into yy_current_state goes here
	yy_current_state = YY_G(yy_start);
//end %% code to get the start state into yy_current_state goes here

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
//%% code to find the next state goes here
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			YY_G(yy_last_accepting_state) = yy_current_state;
			YY_G(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 56 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
//end %% code to find the next state goes here
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YY_CLASS_NAME::yy_try_NUL_trans( yy_state_type yy_current_state )
{
	register int yy_is_jam;
//%% code to find the next state, and perhaps do backing up, goes here
	register char *yy_cp = YY_G(yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		YY_G(yy_last_accepting_state) = yy_current_state;
		YY_G(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 56 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 55);
//end %% code to find the next state, and perhaps do backing up, goes here

	return yy_is_jam ? 0 : yy_current_state;
}

#if 0
//%% update yylineno here
//end %% update yylineno here
//
//%% update BOL and yylineno
	if ( c == '\n' )
		M4_YY_INCR_LINENO();
//end %% update BOL and yylineno
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )

#line 35 "src/parser_xml.l"



//todo amprsand atd znaky
HoeCore::XMLParser::XMLParser()
{
	m_textprop = T("text");
}


void HoeCore::XMLParser::SetProp(StructParserSAX& parser, tchar* text)
{
	const tchar* name = text;
	while (*text != ' ' && *text != '\t' && *text != '=') text++;
	*text = 0; 
	while (*text != '\"') text++;
	text++;
	const tchar* value = text;
	while (*text != '\"') text++;
	*text = 0;
	parser.SetProp(name, value);
}

