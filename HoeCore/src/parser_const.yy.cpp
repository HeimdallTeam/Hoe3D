#line 2 "src/parser_const.yy.cpp"

#line 4 "src/parser_const.yy.cpp"

#define  YY_INT_ALIGNED short int

// -*-C-*- vi: set ft=c:
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * Hoe edited flex.skl
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION FLEX_MAJOR_VERSION
#define YY_FLEX_MINOR_VERSION FLEX_MINOR_VERSION
#define YY_FLEX_SUBMINOR_VERSION FLEX_SUBMINOR_VERSION
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef _WIN32
#include <windows.h>
#endif

#ifdef _LINUX
#define _NOXLIB
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <wchar.h>
#include <stdarg.h>
#include <HoeCore/hoe_types.h>
#include <HoeCore/hoe_flex.h>

#define yytext yytext_ptr

#define YY_CHAR tchar

namespace HoeCore {
namespace flex {

#if 0
//%% YY_CHAR and YY_SC_TO_UI() go here
//%% YY_CHAR and YY_SC_TO_UI() go here
//end %% YY_CHAR and YY_SC_TO_UI() go here

#endif

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER m_buffer
#define YY_CURRENT_BUFFER_LVALUE m_buffer

#define yy_new_buffer yy_create_buffer

#define yy_set_bol(at_bol) \
	{ \
	if ( ! m_buffer ) \
		m_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	m_buffer->SetBol(at_bol); \
	}

#define YY_AT_BOL() (m_buffer->IsBol())

#define M4_YY_INCR_LINENO() 

#if 0
//%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char *yytext;
#define yytext_ptr yytext
//end %% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
#else
//extern YY_CHAR *yytext;
#endif

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
/*%% code to fiddle yytext and yyleng for yymore() goes here */ \
	yyleng = (size_t) (yy_cp - yy_bp); \
/*end %% code to fiddle yytext and yyleng for yymore() goes here*/ \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
/*%% code to copy yytext_ptr to yytext[] goes here, if %array*/ \
/* end %% code to copy yytext_ptr to yytext[] goes here, if %array*/ \
	yy_c_buf_p = yy_cp;

} //namespace flex
} //namespace HoeCore

using namespace HoeCore::flex;

//%% data tables for the DFA and the user's section 1 definitions go here
#define YY_NUM_RULES 11
#define YY_END_OF_BUFFER 12
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_accept[36] =
    {   0,
        0,    0,   12,    9,    1,   10,    9,    9,    9,    9,
        7,    7,    5,    3,    1,    0,    0,    0,    4,    2,
        4,    7,    0,    0,    5,    5,    3,    6,    4,    2,
        4,    4,    8,    7,    0
    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    6,    1,    1,    1,    1,
        1,    1,    7,    1,    7,    8,    9,   10,   11,   11,
       11,   11,   11,   11,   11,   11,   11,    6,    1,    1,
        1,    1,    1,    1,   12,   12,   12,   12,   12,   12,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
        1,    1,    1,    1,   14,    1,   12,   12,   12,   12,

       12,   15,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   16,   13,   13,   13,   13,   13,   13,   13,   17,
       13,   13,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[18] =
    {   0,
        1,    1,    2,    3,    1,    4,    1,    5,    1,    6,
        6,    7,    4,    4,    8,    4,    4
    } ;

static yyconst flex_int16_t yy_base[44] =
    {   0,
        0,   70,   74,   76,   71,   76,    0,   64,    8,   62,
       12,   53,   51,    0,   55,   50,   14,   38,   26,    0,
       17,    0,   14,    0,   13,   12,    0,   76,   76,    0,
        6,   76,   76,    0,   76,   29,   33,   36,   44,   47,
       55,   58,   61
    } ;

static yyconst flex_int16_t yy_def[44] =
    {   0,
       35,    1,   35,   35,   35,   35,   36,   37,   35,   35,
       35,   11,   38,   39,   35,   36,   35,   37,   40,   41,
       42,   12,   35,   43,   38,   38,   39,   35,   35,   41,
       42,   35,   35,   43,    0,   35,   35,   35,   35,   35,
       35,   35,   35
    } ;

static yyconst flex_int16_t yy_nxt[94] =
    {   0,
        4,    5,    6,    7,    4,    4,    8,    9,   10,   11,
       12,   13,   13,   13,   13,   13,   13,   19,   19,   21,
       29,   22,   22,   19,   19,   26,   26,   23,   24,   16,
       33,   32,   16,   16,   16,   16,   16,   18,   18,   25,
       29,   25,   25,   25,   27,   21,   27,   27,   27,   27,
       27,   27,   19,   28,   19,   30,   15,   30,   30,   30,
       30,   30,   30,   31,   26,   31,   34,   34,   34,   35,
       20,   17,   15,   35,   14,    3,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35

    } ;

static yyconst flex_int16_t yy_chk[94] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    9,    9,   11,
       31,   11,   11,   17,   17,   26,   25,   11,   11,   36,
       23,   21,   36,   36,   36,   36,   36,   37,   37,   38,
       19,   38,   38,   38,   39,   18,   39,   39,   39,   39,
       39,   39,   40,   16,   40,   41,   15,   41,   41,   41,
       41,   41,   41,   42,   13,   42,   43,   43,   43,   12,
       10,    8,    5,    3,    2,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35

    } ;

/* Table of booleans, true if rule could match eol. */
static yyconst flex_int32_t yy_rule_can_match_eol[12] =
    {   0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,     };

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "src/parser_const.l"
#line 3 "src/parser_const.l"
#include "StdAfx.h"
#include "../include/HoeCore/const_file.h"
#include "../include/HoeCore/hoe_structures.h"
#include "../include/HoeCore/hoe_mem.h"
#include "../include/HoeCore/hoe_core.h"
#define YY_CLASS_NAME HoeCore::ConstParser

enum Tokens {
	TName = 256,
	TReal,
	TNumber,
	TPixel,
	TString,
}; // stejne jako const_file.cpp

#line 269 "src/parser_const.yy.cpp"
//end of %% data tables for the DFA and the user's section 1 definitions go here

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state ( int new_state );
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state ( void );
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state ( void );
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

/* Echo output. */
#define ECHO \
	do { \
	 int s = this->Echo( yytext_ptr, yyleng ); \
	 if (s) return s; \
	} while (0);

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#if 0
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#define YY_BREAK break;

#if 0
#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

#else
#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		m_buffer->SetBol(yytext_ptr[yyleng - 1] == '\n'); \
	YY_USER_ACTION
#endif

#ifdef YY_CLASS_DECL
int YY_CLASS_NAME::YY_CLASS_DECL
#else
int YY_CLASS_NAME::Lex()
#endif
{
	register HoeCore::flex::yy_state_type yy_current_state;
	register tchar *yy_cp, *yy_bp;
	register int yy_act;
	yy_start = 1; // initial state

//%% user's declarations go here
#line 32 "src/parser_const.l"

#line 385 "src/parser_const.yy.cpp"
//end %% user's declarations go here

/*#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif*/

	if (!m_buffer)
		return YY_NULL;

	while ( 1 )		/* loops until end-of-file is reached */
		{
//%% yymore()-related code goes here
//end %% yymore()-related code goes here
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

//%% code to set up and find next match goes here
		yy_current_state = YY_G(yy_start);
		yy_current_state += YY_AT_BOL();
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				YY_G(yy_last_accepting_state) = yy_current_state;
				YY_G(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 36 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 76 );
//end %% code to set up and find next match goes here

yy_find_action:
//%% code to find the action number goes here
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = YY_G(yy_last_accepting_cpos);
			yy_current_state = YY_G(yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}
//end%% code to find the action number goes here

		YY_DO_BEFORE_ACTION;

#if 0 
//%% code for yylineno update goes here

		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					M4_YY_INCR_LINENO();
			}

//end %% code for yylineno update goes here

#else
		if ( yy_act != YY_END_OF_BUFFER )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					m_buffer->IncLineNo();
			}
#endif //end%% code for yylineno update goes here

do_action:	/* This label is used only to access EOF actions. */

//%% debug code goes here
//end %% debug code goes here

		switch ( yy_act )
	{ /* beginning of action switch */
//%% actions go here
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = YY_G(yy_hold_char);
			yy_cp = YY_G(yy_last_accepting_cpos);
			yy_current_state = YY_G(yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 33 "src/parser_const.l"
/* skip */
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 34 "src/parser_const.l"
/* skip */
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 35 "src/parser_const.l"
/* skip */
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 38 "src/parser_const.l"
return TReal;
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 39 "src/parser_const.l"
return TName;
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 40 "src/parser_const.l"
return TString;
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 41 "src/parser_const.l"
return TNumber;
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 42 "src/parser_const.l"
return TPixel;
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 43 "src/parser_const.l"
return yytext[0];
	YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 44 "src/parser_const.l"
return T('\n');
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 46 "src/parser_const.l"
ECHO;
	YY_BREAK
#line 540 "src/parser_const.yy.cpp"
case YY_STATE_EOF(INITIAL):
	yyterminate();
//end %% actions go here

	case YY_END_OF_BUFFER:
		{
			/* end of buffer -> newread or end */
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( m_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between m_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = m_buffer->yy_n_chars;
			//m_buffer->yy_input_file = stdin;
			m_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &m_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */ 
				/* prislo nul => teoreticky staci jeden*/
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
//%% code to do back-up for compressed tables and set up yy_cp goes here
				yy_cp = YY_G(yy_c_buf_p);
//end %% code to do back-up for compressed tables and set up yy_cp goes here
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&m_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(T("fatal flex scanner internal error--no action found"));
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

/* yy_get_previous_state - get the state just before the EOB char was reached */

yy_state_type YY_CLASS_NAME::yy_get_previous_state()
{
	register yy_state_type yy_current_state;
	register tchar *yy_cp;

//%% code to get the start state into yy_current_state goes here
	yy_current_state = YY_G(yy_start);
	yy_current_state += YY_AT_BOL();
//end %% code to get the start state into yy_current_state goes here

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
//%% code to find the next state goes here
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			YY_G(yy_last_accepting_state) = yy_current_state;
			YY_G(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 36 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
//end %% code to find the next state goes here
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YY_CLASS_NAME::yy_try_NUL_trans( yy_state_type yy_current_state )
{
	register int yy_is_jam;
//%% code to find the next state, and perhaps do backing up, goes here
	register char *yy_cp = YY_G(yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		YY_G(yy_last_accepting_state) = yy_current_state;
		YY_G(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 36 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 35);
//end %% code to find the next state, and perhaps do backing up, goes here

	return yy_is_jam ? 0 : yy_current_state;
}

#if 0
//%% update yylineno here
//end %% update yylineno here
//
//%% update BOL and yylineno
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
	if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )
		M4_YY_INCR_LINENO();
//end %% update BOL and yylineno
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )

#line 46 "src/parser_const.l"



#define ERR(str) { parser.ParseError(T("Error: ") T(str)); return false; }

// parse functions
bool  YY_CLASS_NAME::Parse(ConstParserI& parser)
{
	int token = Lex();
	while (token)
	{
		if (token == T('\n')) 
		{
			token = Lex();	
			continue;
		}
		if (token != TName) ERR("Name requied.");
		// jmeno
		m_name.Set(m_pool.Insert(yytext));
		while ((token = Lex()) == '.')
		{
			if (Lex() != TName) ERR("Property requied.");
			m_name.Add(m_pool.Insert(yytext));
		}
		if (token != '=') ERR("`=' requied.");
		// value
		m_value.Delete();
		while (token = Lex(), token && token != T('\n'))
		{
			// add property
			Token& t = m_value.Add();
			memset(&t, 0, sizeof(Token));
			t.token = token;
			switch (token)
			{
			case TName:
				t.str = m_pool.Insert(yytext);
				break;
			case TString:
			{
				tchar * s = (tchar*)m_pool.Strdup(yytext+1);
				s[yyleng-2] = T('\0');
				t.str = s;
			}	break;
			case TReal:
				t.real = string::GetReal(yytext);
				break;
			case TPixel:
			case TNumber:
				t.number = string::GetNumber(yytext);
				break;
			};
		}
		// process value
		if (!m_value.Count())
			ERR("Value requied.");
		
		// parse value
		if (!ParseValue(parser))
			return false;
		
		if (token == T('\n')) token = Lex();
	}
	return true;
}


